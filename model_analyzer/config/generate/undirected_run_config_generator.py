# Copyright (c) 2022, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from model_analyzer.config.generate.neighborhood import Neighborhood
from .config_generator_interface import ConfigGeneratorInterface

from model_analyzer.config.generate.coordinate import Coordinate
from model_analyzer.config.generate.coordinate_data import CoordinateData
from model_analyzer.config.generate.neighborhood import Neighborhood
from model_analyzer.config.generate.run_config_generator import RunConfigGenerator
from model_analyzer.config.generate.search_config import SearchConfig
from model_analyzer.config.generate.search_dimension import SearchDimension
from model_analyzer.config.generate.model_variant_name_manager import ModelVariantNameManager
from model_analyzer.config.run.model_run_config import ModelRunConfig
from model_analyzer.config.run.run_config import RunConfig
from model_analyzer.constants import LOGGER_NAME
from model_analyzer.perf_analyzer.perf_config import PerfAnalyzerConfig
from model_analyzer.triton.model.model_config import ModelConfig

import logging

logger = logging.getLogger(LOGGER_NAME)


class UndirectedRunConfigGenerator(ConfigGeneratorInterface):

    def __init__(self, config, models, client):
        self._config = config
        self._models = models
        self._client = client
        self._variant_name_manager = ModelVariantNameManager()

        # FIXME
        self._model_repository = config.model_repository
        self._base_model_name = models[0].model_name()
        self._triton_env = RunConfigGenerator.determine_triton_server_env(
            models)

        self._search_config = SearchConfig(
            min_initialized=3,
            dimensions=[
                SearchDimension("max_batch_size",
                                SearchDimension.DIMENSION_TYPE_EXPONENTIAL),
                SearchDimension("instance_count",
                                SearchDimension.DIMENSION_TYPE_LINEAR),
                SearchDimension("concurrency",
                                SearchDimension.DIMENSION_TYPE_EXPONENTIAL)
            ])
        self._coordinate_data = CoordinateData()

        self._current_coordinate = self._get_starting_coordinate()
        self._coordinate_to_measure = self._current_coordinate

        self._radius = 2
        self._magnitude = 2
        self._radius_offset = 0
        self._magnitude_offset = 0

        self._generator_started = False
        self._done = False

    def is_done(self):
        return self._done

    def next_config(self):
        """
        Returns
        -------
        RunConfig
            The next RunConfig generated by this class
        """

        self._generator_started = True
        while True:
            config = self._get_next_run_config()
            yield (config)
            self._step()

    def _step(self):
        # Determine neighborhood
        # If enough data -> pick a new point via vector
        # If not enough -> pick a point in neighborhood to initialize

        # FIXME radius and magnitude
        radius = self._radius + self._radius_offset
        magnitude = self._magnitude + self._magnitude_offset

        neighborhood = Neighborhood(self._search_config, self._coordinate_data,
                                    self._current_coordinate, radius)

        if self._get_last_results() is None:
            self._coordinate_to_measure = neighborhood.get_nearest_unvisited_neighbor(
                self._coordinate_to_measure)
            logger.debug(
                f"No throughput found. measuring {self._coordinate_to_measure}")
        else:
            if neighborhood.enough_coordinates_initialized():
                new_coordinate = neighborhood.calculate_new_coordinate(
                    magnitude)
                if new_coordinate == self._current_coordinate:
                    self._done = True
                if self._coordinate_data.get_visit_count(new_coordinate) >= 2:
                    self._done = True
                logger.debug(
                    f"Stepping {self._current_coordinate}->{new_coordinate}")

                self._current_coordinate = new_coordinate
                self._coordinate_to_measure = new_coordinate
            else:
                self._coordinate_to_measure = neighborhood.pick_point_to_initialize(
                )
                logger.debug(
                    "Need more data. Measuring {self._coordinate_to_measure}")

    def set_last_results(self, measurements):

        self._coordinate_data.increment_visit_count(self._coordinate_to_measure)

        if measurements is not None and measurements[0] is not None:
            self._coordinate_data.set_throughput(
                self._coordinate_to_measure,
                measurements[0].get_non_gpu_metric_value("perf_throughput"))
            logger.debug(
                f"Throughput for {self._coordinate_to_measure}: {self._get_last_results()}"
            )

    def _get_last_results(self):
        return self._coordinate_data.get_throughput(self._coordinate_to_measure)

    def _get_starting_coordinate(self):
        min_indexes = self._search_config.get_min_indexes()
        return Coordinate(min_indexes)

    def _get_dimension_values(self, coordinate):
        dimension_values = {}
        for i in range(self._search_config.get_num_dimensions()):
            dimension = self._search_config.get_dimension(i)
            key = dimension.get_name()
            value = dimension.get_value_at_idx(coordinate[i])
            dimension_values[key] = value

        return dimension_values

    def _get_next_run_config(self):
        # TODO multi-model

        mc = self._get_next_model_config()

        model_variant_name = mc.get_field('name')
        pac = self._get_next_perf_analyzer_config(model_variant_name)

        mrc = ModelRunConfig(self._base_model_name, mc, pac)

        run_config = RunConfig(self._triton_env)
        run_config.add_model_run_config(mrc)

        return run_config

    def _get_next_model_config(self):
        dimension_values = self._get_dimension_values(
            self._coordinate_to_measure)

        base_model_config = ModelConfig.create_from_file(
            f'{self._model_repository}/{self._base_model_name}')
        mc_dict = base_model_config.get_config()

        mc_dict['dynamic_batching'] = {}
        mc_dict['max_batch_size'] = dimension_values['max_batch_size']
        mc_dict['instance_group'] = [{
            'count': dimension_values['instance_count'],
            'kind': "KIND_GPU"
        }]
        mc_dict['name'] = self._variant_name_manager.get_model_variant_name(
            self._base_model_name, mc_dict)

        model_config = ModelConfig.create_from_dictionary(mc_dict)
        return model_config

    # FIXME really need to scrub this
    def _get_next_perf_analyzer_config(self, model_variant_name):
        dimension_values = self._get_dimension_values(
            self._coordinate_to_measure)

        perf_analyzer_config = PerfAnalyzerConfig()

        perf_config_params = {
            'model-name': model_variant_name,
            'latency-report-file': model_variant_name + "-results.csv",
            # FIXME needed?
            'batch-size': self._models[0].parameters()['batch_sizes'][0],
            'measurement-mode': "count_windows",
            'verbose-csv': '--verbose-csv',
            'concurrency-range': dimension_values['concurrency']
        }
        perf_analyzer_config.update_config(perf_config_params)
        return perf_analyzer_config
